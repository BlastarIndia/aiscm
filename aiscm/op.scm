(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm jit)
  #:export (minus)
  #:re-export (+))
(define ctx (make <jit-context>))
(define-method (minus (x <element>))
  (let* ((tx    (class-of x))
         (ftx   (foreign-type tx))
         (ax    (if (eqv? (bits tx) 64) RAX EAX))
         (di    (if (eqv? (bits tx) 64) RDI EDI))
         (code  (asm ctx ftx (list (MOV ax di) (NEG ax) (RET)) ftx))
         (proc  (lambda (x) (make tx #:value (code (get-value x))))))
    (add-method! minus (make <method>
                             #:specializers (list tx)
                             #:procedure proc))
    (minus x)))
(define-method (+ (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
