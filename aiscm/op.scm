(define-module (aiscm op)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:use-module (aiscm jit)
  #:re-export (+ -))
(define ctx (make <jit-context>))
(define-method (+ (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (ADD ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! + (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (+ a b)))
(define-method (+ (a <element>) (b <integer>))
  (+ a (make (match b) #:value b)))
(define-method (+ (a <integer>) (b <element>))
  (+ (make (match a) #:value a) b))
(define-method (- (a <element>) (b <element>))
  (let* ((ta     (class-of a))
         (tb     (class-of b))
         (tr     (coerce ta tb))
         (fta    (foreign-type ta))
         (ftb    (foreign-type tb))
         (ftr    (foreign-type tr))
         (ax     (if (eqv? (bits tr) 64) RAX EAX))
         (di     (if (eqv? (bits tr) 64) RDI EDI))
         (si     (if (eqv? (bits tr) 64) RSI ESI))
         (code   (asm ctx ftr (list (MOV ax di) (SUB ax si) (RET)) fta ftb))
         (proc   (lambda (a b) (make tr #:value (code (get-value a) (get-value b))))))
    (add-method! - (make <method>
                         #:specializers (list ta tb)
                         #:procedure proc))
    (- a b)))
(define-method (- (a <element>) (b <integer>))
  (- a (make (match b) #:value b)))
(define-method (- (a <integer>) (b <element>))
  (- (make (match a) #:value a) b))
