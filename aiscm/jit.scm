(define-module (aiscm jit)
  #:use-module (oop goops)
  #:use-module (system foreign)
  #:use-module (rnrs bytevectors)
  #:use-module (aiscm element)
  #:use-module (aiscm int)
  #:export (jit-call
            ADD
            MOV
            RET))
; http://www.drpaulcarter.com/pcasm/
; http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html
(load-extension "libguile-jit" "init_jit")
(define (jit-call commands)
  (jit-call-bv (u8-list->bytevector (apply append commands))))
(define ADD_r/m32,r32   #x01)
(define ADD_EAX,imm32   #x05)
(define ADD_r/m32,imm32 #x81)
(define MOV_r/m32,r32   #x89)
(define MOV_r32,imm32   #xb8)
(define (opcode op)
  (assq-ref opcodes op))
(define register-codes
  '((EAX . 0)
    (ECX . 1)
    (EDX . 2)
    (EBX . 3)
    (ESP . 4)
    (EBP . 5)
    (ESI . 6)
    (EDI . 7)))
(define (register-code reg)
  (assq-ref register-codes reg))
(define-method (ADD (r/m32 <symbol>) (r32 <symbol>))
  (let ((op ADD_r/m32,r32)
        (reg (register-code r32))
        (r/m (register-code r/m32))
        (mod #b11))
    (append (list op) (list (logior (ash mod 6) (ash reg 3) r/m)))))
(define-method (ADD (r/m32 <symbol>) (imm32 <int>))
  (let ((id (bytevector->u8-list (pack imm32))))
    (if (eq? r/m32 'EAX)
      (let ((op ADD_EAX,imm32))
        (append (list op) id))
      (let ((op ADD_r/m32,imm32)
            (r/m (register-code r/m32))
            (mod #b11))
        (append (list op) (list (logior (ash mod 6) r/m)) id)))))
(define-method (MOV (r/m32 <symbol>) (r32 <symbol>))
  (let ((op MOV_r/m32,r32)
        (reg (register-code r32))
        (r/m (register-code r/m32))
        (mod #b11))
    (append (list op) (list (logior (ash mod 6) (ash reg 3) r/m)))))
(define-method (MOV (r32 <symbol>) (imm32 <int>))
  (let ((op  MOV_r32,imm32)
        (reg (register-code r32))
        (id  (bytevector->u8-list (pack imm32))))
    (append (list (logior op reg)) id)))
(define (RET) '(#xc3))
