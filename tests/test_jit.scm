(use-modules (oop goops)
             (system foreign)
             (rnrs bytevectors)
             (aiscm jit)
             (aiscm element)
             (aiscm mem)
             (aiscm int)
             (aiscm pointer)
             (guile-tap))
(planned-tests 28)
(define n1 (make <int> #:value 42))
(define n2 (make <int> #:value 13))
(define m  (make <mem> #:size 12))
(define p  (make (pointer <int>) #:value m))
(define n3 (make <int> #:value (pointer-address (get-memory m))))
(store p n1)
(store (+ p 1) n2)
(ok (equal? '(#xb8 #x2a #x00 #x00 #x00) (MOV EAX n1))
    "MOV EAX, 42")
(ok (equal? '(#xb9 #x2a #x00 #x00 #x00) (MOV ECX n1))
    "MOV ECX, 42")
(ok (equal? '(#x89 #xc3) (MOV EBX EAX))
    "MOV EBX, EAX")
(ok (equal? '(#x89 #xd1) (MOV ECX EDX))
    "MOV ECX, EDX")
(ok (equal? '(#x8b #x0a) (MOV ECX *EDX))
    "Read data from address into register")
(ok (equal? '(#x89 #x11) (MOV *ECX EDX))
    "Write data from register to address")
(ok (equal? '(#xc3) (RET))
    "RET # near return")
(ok (eqv? 42 (jit-call (list (MOV EAX n1)
                             (RET))))
    "Function returning constant in EAX")
(ok (eqv? 42 (jit-call (list (MOV EBX n1)
                             (MOV EAX EBX)
                             (RET))))
    "Function copying content from EBX")
(ok (equal? '(#x05 #x0d #x00 #x00 #x00) (ADD EAX n2))
    "ADD EAX, 13")
(ok (equal? '(#x81 #xc3 #x0d #x00 #x00 #x00) (ADD EBX n2))
    "ADD EBX, 13")
(ok (equal? '(#x01 #xd1) (ADD ECX EDX))
    "ADD ECX, EDX")
(ok (eqv? 55 (jit-call (list (MOV EAX n1)
                             (ADD EAX n2)
                             (RET))))
    "Function using EAX to add 42 and 13")
(ok (eqv? 55 (jit-call (list (MOV EDX n1)
                             (ADD EDX n2)
                             (MOV EAX EDX)
                             (RET))))
    "Function using EDX to add 42 and 13")
(ok (eqv? 55 (jit-call (list (MOV EAX n1)
                             (MOV ECX n2)
                             (ADD EAX ECX)
                             (RET))))
    "Function using EAX and ECX to add 42 and 13")
(ok (equal? '(#x90) (NOP))
    "NOP # no operation")
(ok (eqv? 42 (jit-call (list (MOV EAX n1)
                             (NOP)
                             (NOP)
                             (RET))))
    "Function with some NOP statements inside")
(ok (equal? '(#x52) (PUSH EDX))
    "PUSH EDX")
(ok (equal? '(#x57) (PUSH EDI))
    "PUSH EDI")
(ok (equal? '(#x5a) (POP EDX))
    "POP EDX")
(ok (equal? '(#x5f) (POP EDI))
    "POP EDI")
(ok (eqv? 42 (jit-call (list (MOV EDX n1)
                             (PUSH EDX)
                             (POP EAX)
                             (RET))))
    "Function using PUSH and POP")
(ok (eqv? 42 (jit-call (list (MOV ECX n3)
                             (MOV EAX *ECX)
                             (RET))))
    "Function loading value address given as integer")
(ok (eqv? 42 (jit-call (list (MOV ECX p)
                             (MOV EAX *ECX)
                             (RET))))
    "Function loading value from address given as pointer")
(ok (eqv? 13 (jit-call (list (MOV ECX p)
                             (ADD ECX (make <int> #:value 4))
                             (MOV EAX *ECX)
                             (RET))))
    "Function loading value from address with offset")
(ok (equal? '(#xe9 #x2a #x00 #x00 #x00) (JMP n1))
    "JMP 42")
(ok (eqv? 42 (jit-call (list (MOV EBX n1)
                             (JMP (make <int> #:value (length (MOV EBX n2))))
                             (MOV EBX n2)
                             (MOV EAX EBX)
                             (RET))))
    "Function with a local jump")
(ok (eqv? 21 (begin (jit-call (list (MOV ESI (+ p 2))
                                    (MOV EBX (make <int> #:value 21))
                                    (MOV *ESI EBX)
                                    (RET)))
                    (get-value (fetch (+ p 2)))))
    "Function writing value to memory")
(format #t "~&")
