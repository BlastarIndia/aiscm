(use-modules (aiscm jit)
             (aiscm int)
             (oop goops)
             (rnrs bytevectors)
             (guile-tap))
(planned-tests 13)
(define n1 (make <int> #:value 42))
(define n2 (make <int> #:value 13))
(ok (equal? '(#xb8 #x2a #x00 #x00 #x00) (MOV 'EAX n1))
    "MOV EAX, 42")
(ok (equal? '(#xb9 #x2a #x00 #x00 #x00) (MOV 'ECX n1))
    "MOV ECX, 42")
(ok (equal? '(#x89 #xc3) (MOV 'EBX 'EAX))
    "MOV EBX, EAX")
(ok (equal? '(#x89 #xd1) (MOV 'ECX 'EDX))
    "MOV ECX, EDX")
(ok (equal? '(#x05 #x0d #x00 #x00 #x00) (ADD 'EAX n2))
    "ADD EAX, 13")
(ok (equal? '(#x81 #xc3 #x0d #x00 #x00 #x00) (ADD 'EBX n2))
    "ADD EBX, 13")
(ok (equal? '(#x01 #xd1) (ADD 'ECX 'EDX))
    "ADD ECX, EDX")
(ok (equal? '(#xc3) (RET))
    "RET # near return")
(ok (eqv? 42 (jit-call (list (MOV 'EAX n1) (RET))))
    "Function returning constant in EAX")
(ok (eqv? 42 (jit-call (list (MOV 'EBX n1) (MOV 'EAX 'EBX) (RET))))
    "Function copying content from EBX")
(ok (eqv? 55 (jit-call (list (MOV 'EAX n1) (ADD 'EAX n2) (RET))))
    "Function using EAX to add 42 and 13")
(ok (eqv? 55 (jit-call (list (MOV 'EDX n1) (ADD 'EDX n2) (MOV 'EAX 'EDX) (RET))))
    "Function using EDX to add 42 and 13")
(ok (eqv? 55 (jit-call (list (MOV 'EAX n1) (MOV 'ECX n2) (ADD 'EAX 'ECX) (RET))))
    "Function using EAX and ECX to add 42 and 13")
(format #t "~&")
